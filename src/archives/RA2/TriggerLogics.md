---
category:
  - RA2
  - 地图
tag:
  - 地图编辑
  - 触发
  - 局部变量
star: true
---

# 红警 2 地图触发组件的逻辑原理

::: important 阅览注意
本文的章节安排是有意模仿我的毕业论文的。也由于本文的内容比较硬核，没有了解过程序设计的地图作者可能会有阅读困难。  
对此，我会试图在有涉及的地方以这种注解的形式加以「翻译」。
:::

## 绪言

红警 2 的地图创作，但凡要实现一些功能的，首先会想到的必然是触发和 INI。
特别是单人战役和多人合作战役，离开了触发，剧情流程也就荡然无存^1^，其本质便只剩下遭遇战了。

然而，大部分的地图创作者们由于缺乏对触发比较明晰的认识，圈子里的教程也往往偏「实用主义」，
他们经常是「知其然而不知其所以然」，若需要加入稍微复杂一点的流程设计，往往束手无策。

我们已知一条基本哲理：复杂事物是若干简单事物的有机组合。由于触发与数学的「命题」——若 p 则 q——非常类似，
因此私以为从逻辑层面剖析触发的运行原理对于复杂触发的设计应能起到一定指导作用，
并与`Ares` `Phobos`等扩展平台一道为我们展现出`gamemd.exe`这个古董的更多可能性。

## 一、触发组件相关理论基础

### 1.1 触发

地图触发是早在「命运与征服：泰伯利亚黎明」就引入的系统，负责处理地图当中的 **「事件」**^1^。  
一局游戏瞬息万变，其中总有一些**既成的、游戏引擎能感知的事**，对于设计者来说意义非凡：
什么关键建筑被打爆了啊，哪家缺电缺钱了，都可以是「事件」，驱动触发去执行相应的「行为」。
**「行为」**则是各种各样**平台能做到的效果**：可以是刷兵，改变光照，炸个桥，平地起心灵信标，等等。  
需要强调的是，「事件」和「行为」并不是臆想出来的，直到`Phobos`平台之前还没有触发可以帮你存档呢。

::: note 「事件」「行为」
对于没有接触过编程的读者来说，你可以简单将「事件」理解为「条件」，「行为」则理解成「结果」。
:::

在红警 2，触发更类似于数学中的命题：「若 p 则 q」，其中事件 p 和行为 q 都可以不止一条，并且 p1 p2 p... 之间、q1 q2 q... 之间有一定的连接关系。

### 1.2 局部变量

变量系统则在「命运与征服：泰伯利亚之日」才开始出现，根据`[VariableNames]`小节所处的位置不同，
分为 Rules 里的**全局变量**，和地图里的**局部变量**^2^。本文主要讨论局部变量。

在地图创作中，局部变量就是**对设计者有具体意义的**，**会因触发**（和动作脚本）**做出改变的**，**临时在某一局游戏起作用的**数值。

值得一提的是，从原版一直到 Ares 扩展平台，局部变量均有**上限 100 个**、`bool`**类型的限制**。  
直到 [@secsome](https://github.com/secsome) 在 Phobos 平台引入了无限量`int32`扩展局部变量，这种限制才被打破。

> 参考链接：
> [pr#321](https://github.com/Phobos-developers/Phobos/pull/321),
> [pr#424](https://github.com/Phobos-developers/Phobos/pull/424),
> [pr#425](https://github.com/Phobos-developers/Phobos/pull/425).

::: note 数值的类型
数值类型在大多数编程语言中应该都是一脉相承的：
- `bool`：布尔（所谓开关），通常分为`0`（表示否定）和`1`（表示肯定）两种取值；
- `short`：短整数（或称`int16`），因为是 16 位，可至多表示 2^16^ - 1，即`65535`。
- `long`或`int`：长整数（即`int32`），有些玩家应该很熟悉 2^32^ - 1，即`2147483647`。

更详细的内容还请移步「计算机组成原理」第二章：数据的表示与运算。

顺带一提，动作脚本中的扩展局部变量至多只能是`short`类型，因为脚本实际就一个`int`参数，
只不过以 16 位为界恰好可以切分出两个`short`而已。
:::

## 二、触发组件的程序逻辑分析

### 2.1 触发的逻辑本质

在程序语言里，有一种分支结构称为`if`用来描述上述的「若 p 则 q」：
```c
if (condition) // 条件
  do_something();  // 结果
```
抛开触发的所属、难度开关等等其他属性，我们不妨就把一个触发当成是这种`if`结构。

> [!IMPORTANT]
> 为了方便讨论，「允许/禁止触发」的行为不会直接使用`do_something()`这种函数表示。

::: details 触发行为在 INI 和引擎中的实际表示

以触发行为为例，触发行为在地图里是这种 INI 表示：
```ini
0x01BF52 = ActionsCount, Action1_Type, *Params[6], WaypointParam, Action2_Type, ...
```
在游戏引擎中，一条`ActionX`由`TActionClass`管理（下列声明有所省略，详见 [YRpp](https://github.com/Phobos-developers/YRpp/blob/c8d4da4f57a80a3cc2b9ecbde56c335e082c8335/TActionClass.h)：
```cpp
class TActionClass : public AbstractClass {
public:
	TriggerAction      ActionKind;  // ActionX_Type
	union {
		RectangleStruct    Bounds; // map bounds for use with action 40
		struct {
			int Param3;
			int Param4;
			int Param5;
			int Param6;
		};
	}; // It's enough for calling Bounds.X, just use a union here now. - secsome
	int                Waypoint;   // WaypointParam
	int                Value2; // multipurpose  // Params[1], or P2
	int                Value; // multipurpose   // Params[0], or P1
};
```
其中 P1 决定了 P2 参数的类型。由于 P3-P6 均为`int`类型，无法满足文本、数值、触发等多种类型需求，所以由 Value (P1) 采取类似`enum`的设计，
Value2 则记录真实参数 P2 的指针地址。
:::

::: details 触发行为的具体实现
游戏引擎仍然用`TActionClass`声明和实现原版的行为（也就是地编靠前的 100 多号），扩展平台则用`TActionExt`实现扩展。
以 Phobos 的「编辑变量」功能为例：
```cpp
bool TActionExt::EditVariable(
  TActionClass* pThis, HouseClass* pHouse, ObjectClass* pObject,
  TriggerClass* pTrigger, CellStruct const& location)
{
  // blabla
  return true;
}
```
- `pThis`为`TActionClass`的指针，在「触发行为在 INI 和引擎中的实际表示」中已经介绍过，它可以记录行为参数；  
- `pHouse`系触发所属方，比如行为 36 - 全部更改所属 要变走「触发所属方」的全部东西。  
- `pObject`是关联对象，也就是地编里点某个建筑、载具出来的「关联触发」。  
- `pTrigger`是这条行为归属的触发，作用我还不清楚。  
- `location`可能是路径点，有可能是别的什么表示位置的玩意，我也不清楚。
:::

至于事件`condition`和行为`do_something()`，我们已在[理论基础](#_1-1-触发)中论述过它们可以不止一条。那么多条件和多结果是如何串起来的呢？
你可以自行翻阅各扩展平台的 YRpp，或是在 FA2 等地图编辑器中实验一下，这边就直接说结论了：

- 多个条件之间**以逻辑且（AND）连接**，所有条件**必须全部满足**，才可以执行对应的结果；
- 多个结果之间链式组织，但因为每一条结果执行耗时极短，表面上看似乎是同一帧内同时完成。

### 2.2 从程序执行流说起……

#### 2.2.1 顺序结构

以被广为改编的「脑死」为例，「脑死」的任务流程具有很典型的顺序性：首先需要建立一座~~锅盖~~苏军雷达，然后打掉最后一座心灵控制器之后扫黑除恶。
实际上，大部分的剧情流程也是这种线性结构，将目标从头执行到尾。

而程序当中最常见的莫过于这种顺序结构：
```c
int main(void) {
  printf("hello world");
  printf("\n");
  printf("by ssks");
  return 0;
}
```
上面的 C 语言代码中，首先在终端中打出`hello world`这一串鹰文，然后打出`\n`换行，最后在下一行打出`by ssks`又一串。
这样的「首先……然后……最后……」可以表明，上述`main(void)`当中的语句是**逐条、自上而下执行**的，这就是程序中的**顺序结构**。

既然如此，我们不妨就把一整局战役当作一个超大的`main`函数。并且，我们已知了触发可以用`if`语句表示，
那么实际上由触发主导的任务流程便可以看作是一个个`if`串联起来的函数主体：

```c
int Braindead(void)  {  // 脑死
  // [intro] 0. start
  if (true) {  // 事件 8 - 任何事件
    DisableUserInput();  // 行为 46 - 禁止用户输入
    PlayEVA("EVA_EstablishBattlefieldControl"); // 行为 21 - 播放语音
  }
  // [intro] 1. brief, init stage1
  if (TimeElapsed(6)) { // 事件 13 - 流逝时间（游戏秒
    ShowText("……是这样的，xx只需要blabla就可以，而……要考虑的就很多了。"); // 行为 11 - 文本触发
    SpawnReinforcement("0X01BF52"); // 行为 7 - 援军小队 // 顺带一提 0x01BF52 = 114514
  }
}
```

在上述的代码段中，我们可以看到有两个触发`[intro] 0. start`和`[intro] 1. brief, init stage1`。
其中，0 号触发的条件是`true`，无需判断便立即执行`{}`里的块，也就是常见的战役开局。
1 号触发紧接在 0 号后面，说明 1 号需要等 0 号执行了方可执行。结合前面对「顺序结构」的叙述，我们不难想到一个行为：53 - 允许触发。

大部分任务的设计大体上就是由「允许触发」串起来的流程链条。

#### 2.2.2 循环结构

注意到触发中有这么一个选项：「重复类型」。

![FA2 触发编辑器属性页](fa2_trigger_ui.webp)

其中重复类型有以下三种取值（目前没有第四种！）

0. 任一（关联对象）满足事件，触发一次
1. 所有（关联对象）满足事件，触发一次
2. 任一（关联对象）满足事件，重复触发

可以看到，触发是有可能重复的。那么重复起来的触发长啥样呢？以最简单的开局无条件输出文本为例，将其改造为重复触发后
该触发会逐帧向屏幕的字幕区（一般在游戏左上角）打出`Hello World`文本。由于红警里 1 秒 = 15 帧，所以这个动作实际上非常快：
```
Hello World
Hello World
Hello Wor
Hello W
Hell
He
```
而在程序语言中，`while`则取代`if`扮演这个执行重复主体的角色：
```c
int main(void) {
  while (1)
    printf("Hello World\n");
}
```
将上述 C 语言代码粘贴进 IDE 编译运行，你也能看到终端里打出来一行行`Hello World`，除非用任务管理器干掉这个进程，否则它会无休止地输出下去。

分析这个 C 语言代码不难发现，首先它走到`while (1)`处执行判断，由于`bool`里 1 为真，条件满足，执行`printf`；然后循环并没有结束，它重新回到`while (1)`处重复执行前面说的流程，将坏掉的乐土打字机事业推进下去~~爱莉希雅死辣~~。

「重复触发」也是类似的道理，一个「等待条件满足→执行结果」的循环。至此，我们可以用`while`循环表示一个重复触发了：
```c
while (TimeElapsed(6)) { // 每隔 6 秒
  ShowText("Warning!");  // 输出文本
  SpawnReinforcements("0X01BF52"); // 刷出臭援军（
}
```

### 2.3 「选择肢」—— 借用 GalGame 的设计思维

触发的选择结构与一般程序语言的`if-elif-else`和`switch-case`不同。
红警 2 的触发只定义了「若 p 则 q」的语义，对于 p 不满足的情形，触发并没有别的措施，自然没有`elif`和`else`这种设计；
而至于`switch-case`，原版的局部变量是`bool`类型，讨论多种`case`也没有什么意义。

不如说，触发的选择结构更像是玩 GalGame 时的剧情分叉，或者说「选择肢」。通常来说，你选择了某一条分支，就沿着这条线一直走向结局（可能 BE 也可能 HE），并没有回头路。触发的选择也是同样的机制：**保留自身，排除异己**。

我们以“选中某个建筑，某建筑就刷漆归我，但只能选一个建筑”这个例子为例。那么自然地，我们先把“选中刷漆”的功能做出来。
```c
if (ObjectSelected(pObject_A)) {   // 事件 36 - 被玩家选中（注意，多人合作任务不可用）
  ChangeOwner(pObject_A, houseid); // 行为 14 - 更改（关联对象）所属（至特定所属方）
}
if (ObjectSelected(pObject_B)) {
  ChangeOwner(pObject_B, houseid);
}
if (ObjectSelected(pObject_C)) {
  ChangeOwner(pObject_C, houseid);
}
```
接下来就是选择了。既然同一帧内不可能点两个建筑，那么我们完全可以趁你改某一个建筑所属的时候，把其他改所属的触发给 ban 掉。
（下面的代码为了演示方便，改用 Python 写法）
```python
def selection_getA():   # 只是一条触发声明
  if ObjectSelected(pA):
    ChangeOwner(pA, houseID)
    del selection_getB  # 行为 12 - 摧毁触发事件
    del selection_getC
  return True

def selection_getB():
  if ObjectSelected(pB):
    ChangeOwner(pB, houseID)
    del selection_getA
    del selection_getC
  return True

def selection_getC():
  if ObjectSelected(pC):
    ChangeOwner(pC, houseID)
    del selection_getA
    del selection_getB
  return True
```
如果你需要像 GalGame 那样表达一种「除了 SL 没有回头路可选」的决绝，那么最好还是用行为 12；
而若是用行为 54 - 禁止触发，那么别的分支仍有可能在后续流程中「死灰复燃」。

### 2.4 触发的时序关系

前面基于程序代码论述了触发在不同执行流中的逻辑表现，但实际上，触发并不总是这么「循规蹈矩」。
事实上，许多 UI 程序和 web 程序对于这种「触发器」的设计是异步的：你在点了某个按钮之后程序会执行一些业务，但这不应该影响你去操作别的按钮。
触发也一样。

两个触发之间其实并没有特别明显的制约关系，同一帧内其实也允许两条触发同时执行。以上面那三个`def`为例，你可以将行号当作时间轴，把那三个`def`并排放（比如 VSCode 允许你对同一个文件纵向分屏），这样三者间的关系可能更清楚些。

#### 2.4.1 时序基本原则

若没有特别限定，**默认的触发是没有遭到「禁止」**（也就是开局就「允许」），**所有难度都可以执行的**。这种情况下，它**从开局就开始等待事件**（或者说判断条件），
一旦有这么一个事件（组）（或者说条件（组）满足），它就执行相应的行为。

**如果该触发只执行一次，则行为执行完毕时触发废止**，后续也不再接受其他「允许触发」的唤醒；**若是重复触发，则行为执行结束后接着等待**（详见[循环结构](#_2-2-2-循环结构)）。而对于重复类型 1 - 所有满足，触发一次，情况则有点复杂。

对于地图上**预先摆着的实体，「所有满足，触发一次」就是字面意思**。好比我把指定的猴子全炸了，才出来一句「文体两开花」。但小队不同。  
小队当中可以不止一个成员，同样一局游戏可以有好几批同种小队。对于**某一批小队里的所有成员，「所有满足，触发一次」字面义同样适用**，也很容易理解；但对于**不同批次的小队，有多少批次触发就会执行多少次**，届时该触发实际上变成了重复触发。例子嘛，可以参考原版 RA2（不是尤里复仇）的盟军 11：核爆辐射尘，有一个经典的工程师修桥名场面。

#### 2.4.2 强制触发

这种启动方式我没有使用过，下面对其原理的叙述也仅凭我个人的脑测。如果有人真的用过，希望你不吝赐教。[我的 Email](mailto:caclx@outlook.com)

已知触发会从被允许起逐帧判断条件，待到条件全部满足才执行相应的结果。那么强制触发有可能是立刻标注条件满足，这样触发判断条件已达成，于是开始相应的流程。

当然，再次强调，**只是猜测**。

### 2.5 引入局部变量后触发逻辑的变化

前面的分析都是基于触发系统本身，贴的代码也只是对假想条件和结果的调用。我们注意到「运输船找妈妈」这一经典例子中运用了局部变量，那么引入局部变量后触发逻辑有什么变化呢？

首先考虑局部变量的位置。C 语言里的局部变量不允许在声明之前就使用：
```c
int main(void) {  // buxv
  i += 1;  // 全局也没有 i，我们就假定你的 main.cpp 就这么点。别杠了。
  int i;
}
```
在 FA2 的局部变量窗口中，你需要为局部变量起名（声明），同时为这个变量赋初值（初始化）。
那么这些局部变量保存到地图的`[VariableNames]`里肯定也是带着初值的（如果你没赋，默认也是 0，如没）。
这些局部变量最终又被引擎读进内存，初始化成`bool[]`或是`int[]`。所以，在游戏开始之前，这些变量就已经就位了。

那么我们不妨把局部变量放在`main()`的开头：
```c
int main(void) {
  bool badguy1_gone = false;  // C 语言不许空格变量名，但局部变量可以："badguy1 gone"
  int player_captured_oil = 0;
  // [intro] 0. INIT
  if (true) { ... }
}
```

既然声明了局部变量，那么就要用起来。触发里有一组事件和一组结果分别读写局部变量（设待操作的局部变量为`x`）：

- 事件 36：（指定）局部变量被设定（值为 1）=> x = 1？
- 行为 56：设置（指定）局部变量（值为 1）=> 令 x = 1

- 事件 37：（指定）局部变量被清除（0）=> x = 0？
- 行为 57：清除（指定）局部变量（值）=> 令 x = 0

翻译成 C 语言伪代码如下：
```c
// 这些宏后面仍会用到。
#define bool char
#define true 1
#define false 0
#define and &&
#define or ||
#define not !

bool x = false;
if (x == 0) // 事件 37
  x = 1; // 行为 56
if (x == 1) // 事件 36
  x = 0; // 行为 57
```
再次提醒，这两个`if`指代的触发可以不是顺序结构。~~否则这样颠来倒去的着实很蠢。~~

触发就是通过对局部变量值的变动，以实现一些较为复杂的逻辑判断。并且随着`int32`扩展局部变量的出现，触发的判断也不再局限于 0 和 1 的「左手倒右手」，而是与科技类型、超级武器、随机数等联系了起来，实现更加精细的随机机制和流程控制。

## 三、基本触发组件存在的问题

### 3.1 只有「且」的逻辑运算局限性较大

从上面的分析中不难发现，红警 2 的触发条件判断只遵循逻辑「且」运算，同时并没有对条件（组）不满足时作出补充。
这样实际上对剧情流程的设计额外带来了困难，纸面上可能还有「或」「非」逻辑的触发设计，但落实到地编里却没法直观地做出来，最后可能就干脆砍设定了。
这无疑抑制了红警 2 同人战役地图、mod 剧情创作的叙事创新。

### 3.2 触发的事件和行为仍受引擎和扩展的限制

由于以前的逆向水平有限，RP、NP、NPExt 与其说是「扩展平台」，不如说是对`gamemd.exe`本身打补丁。并且当时的 mod 圈子更重视 INI 花活，很多 mod 遭遇战体系很成熟，但战役却莫得；就算是有，由于认识不足，表现效果也远不如今。

而 Ares、Phobos 等平台的出现，虽然逆向成果更趋完整，一定程度上也扩展了已有的触发库，但叙事如何设计还是得看平台脸色。若是平台没有轮子，地图师也不可能搞出「检测游戏目录下是否有`rules*.ini`，若有则游戏失败」这种反作弊来。

## 四、对上述问题的相关解决方案

### 4.1 通过局部变量实现「或」「非」逻辑运算

依据软硬件的逻辑等价性原理，触发确实可以做到或、非逻辑的判定。但显然，用软件实现的乘法相比起直接一条 mul 汇编指令，总是麻烦得多。自行实现的或、非逻辑也一样。

#### 4.1.1 「或」运算——殊途同归

假定我要办一场肉人运动会，锻炼下他们在战场的跑腿能力，设有 A、B、C 三个不同国籍的肉人参赛，要求三人**无论谁抢先到达终点，啦啦队都要欢呼**。
那么这件事翻译过来就是要判断`A or B or C`。

那既然是运动会，自然终点线得是同一条，所以三个国籍三条终点线、分别判定的选择结构方案显然被驳回了。这时候我们不妨考虑「触发的关联」，三个国籍都判断己方「进入事件」，然后通过关联触发链接在一起。

::: note 关联触发
你可以将触发以链式方式组织起来，以共享同一个关联对象（或「单元标记」划定的区域）。  
关联遵循如下规则：

- 根触发作为**链头，绑定一切该关联的东西**。比如上述例子里 A 决定承担划终点线的重要使命，所以 A 的判定是根触发。
- 其他触发则作为**链表节点，被根触发关联**。比如还是这个例子，B 同意提案，所以 A 关联 B；C 眼见他们都敲定了，只能跟风，所以 B 绑定 C。
- 链尾不绑定任何触发，也不许绑定根触发当作循环链表。

总结起来就是谁去绑定实体，谁就是领头，要承担关联小弟触发的职责。例子中的 B 既被 A 牵着，同时它绑定到实体后也需要去关联 C。
:::

三个国籍的判定写完需要报胜利者，同时设置局部变量通知啦啦队欢呼：
```c
bool cheers = 0;
if (Entered(A)) {
  ShowText("A won");
  cheers = 1;
}
if (Entered(B)) {
  ShowText("B won");
  cheers = 1;
}
if (Entered(C)) {
  ShowText("C won");
  cheers = 1;
}
// real cheers
if (cheers == 1) {
  Cheers(A);
  Cheers(B);
  Cheers(C);
  ShowText("... 圆满结束致辞 ...");
  // blabla
}
```
可以看到，无论是哪一队踩到了终点线，整个「踩终点线」的条件组都会满足，也就相应执行起欢呼的流程。这就是「或」的精髓——一真皆真。

#### 4.1.2 「非」运算——逆向思维

与上述「或」运算的实现不同，触发的「非」运算仍需要借助原条件。

举个例子，游戏里基洛夫飞艇飞得比较慢，我们就假定它要送~~外卖（大嘘）~~ 炸弹吧。要求指定时间内摧毁目标。
那么对于基洛夫要判断两件事：

- 计时器没超时（流逝时间小于指定值）
- 摧毁目标

翻译过来就是`ObjectDestroyed(target) and not TimeElapsed(max))`。

我们首先假定它超时了，超时就任务失败嘛。那么它原本应该是能完成任务的。所以伪代码这么写：
```c
bool mission_in_time = true;  // 我的变量名取「及时」的语义，代表任务初始可以完成
if (TimeElapsed(max))   mission_in_time = false;
if (mission_in_time == 1 and ObjectDestroyed(target)) {
  // blabla
}
```
这样一来，触发通过判断原条件「已经过了指定时间」成立，反向推出「仍在指定时间内」这一条件不成立，实现了对「超时」的判断。  
总之，我们可以借助局部变量的`bool`开关特性，将判断「条件的否定」分解为「判断条件」和「给条件取反」两个步骤，
并用局部变量将「条件的否定」带给其他触发，间接完成条件的「非」运算。

### 4.2 通过脚本语言等方式对游戏作更全面的干预

这一部分恕我没有办法作具体的展开，圈子里已经有一些大佬这么探索了。简而言之，可以嵌入调用`Lua`脚本的触发，以此为接口提供外部操作的可能；
也可以用别的方法实现 terminal 对游戏内对象的干预，有了 terminal 了自然便可以考虑 Batching，也就是多条命令编写的 Scripts。

## 结论

综上所述，红警 2 的触发在逻辑层面上类似`if`单分支语句的设计，支持顺序、选择、循环三种结构，可以实现大部分任务所需的线性叙事。然而其在逻辑运算上又有所欠缺，导致要追求完整的逻辑判断要通过局部变量绕路实现，对于地图师的逻辑思维能力是一大考验。

并且，随着时代变迁，触发的客制化需求也与日俱增，人们已经不再满足于扩展平台炒的大锅饭，开始转向脚本式的外部干预。但截至 24.6.17 尚没有公开、可行的相应方案。

综上所述，红警 2 对剧情表现的探索仍有很长的路要走。

## 参考文献

1. ModEnc. `Triggers [EB/OL]`, [https://modenc.renegadeprojects.com/Triggers](https://modenc.renegadeprojects.com/Triggers), 1.31.2024, 6.17.2024.
2. ModEnc. `VariableNames [EB/OL]`, [https://modenc.renegadeprojects.com/VariableNames](https://modenc.renegadeprojects.com/VariableNames), 5.16.2024, 6.17.2024.
3. [RN Studio](https://github.com/revengenowstudio). `Map Tutorial [EB/OL]`, [https://github.com/revengenowstudio/map_tutorial](https://github.com/revengenowstudio/map_tutorial), 4.29.2024, 5.6.2024.

> [!NOTE]
> 上述参考文献大致遵循 GB/T 7714 规范。如有误还请在 Issues 或 Pull Requests 中指出。

## 致谢

首先需要感谢圈子里孜孜不倦地逆向`gamemd.exe`这块老古董的大佬们。没有你们的代码支持，我对触发组件逻辑执行的论证将始终停留在猜测层面上。  
然后得感谢各大与我交流过的 mapper 大佬们。你们的经验为这篇文章留下了非常重要的注脚。  
最后感谢模组「星辰之光」的玩家和相关创作人士对本文疵漏作出的补充修正。
